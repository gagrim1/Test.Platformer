# Что там у нас по файлам

## Структура сцены

Согласен с папками (читать *объектами*) **UI** и **Environment**(может переименовать?).

Не уверен по поводу деления внутри папки **Objects** - может, делить с помощью тегов типы объектов? И вообще, пока в проекте объектов таких нет, можно пока не акцентировать на этом внимание.

**Controller** - самое спорное, но пока не понятно, что вообще делать.

**Player(Test)** - зачем? Удалить.

## Мое видение структуры сцены

...

## Необходимые packages

Надо обсудить используемые пакеты. Может, в той папке ненужный нам мусор валяется.

Кто-то пользуется JetBrains Rider? Если нет, можно пакет убрать.

***Такие пакеты очень даже можно и нужно закинуть в .gitignore***.

## Папка assets

**FromStore** - со временем можно избавиться, но пока пофиг.

**Materials** - что там за материал непонятный одинокий?

**Player** - надо закинуть в папку **Prefabs**

**Scripts** - пока жестоко. Следы MVC, который не вышел, и т.п.

# Что там у нас по коду (отдельные мысли)

Начну с тех моментов, что висели в голове, чтобы не забыть.

## HealthSystem

Подточен конкретно под player. Было бы хорошо сделать его как можно общим. Ну в данном случае, практически, убрав это:

```
IEnumerator StayImmortal()
    {
        if (canDamage == true)
        {
            canDamage = false;
            yield return new WaitForSeconds(1.0f);
            canDamage = true;
        }
    }
```

Зачем? Чтобы на изи прикреплять эту дичь и к врагам, и к чему-либо, что имеет здоровье. То есть, оставляем само здоровье, методы дамага-хила, геттеры-сеттеры ну и всё.

Как потом быть с игроком? Ну можно попробовать в наследование скриптов, например, с целью расширить функционал.

### Идея

Есть такой паттерн - декоратор. Его суть в том, чтобы вместо изменения простого функционала к сложному, мы сделали новый функционал, который что-то делает, потом использует простой, потом опять что-то делает. Таким образом, он "оборачивает" наш простой функционал, не изменяя его. Или же можно рассмотреть это как *препроцесс-процесс-постпроцесс*.

Пример - герой выпил зелье, которое уменьшает получаемый урон на *n%*. Можно усложнить нашу систему, добавив кучу флагов и переменных, а можно сделать так - обертка, которая получает урон, потом значение урона пропускает через шаги препроцессинга (в том числе, через эффект нашего зелья), затем вот этот обработанный урон отправляет к простейшей системе, затем получает выход в виде текущего здоровью, ну и что-то там еще с ним делает (пост-процесс).

Ключевой момент - мы не изменяем более простую функцию, а добавляем обертку, при этом с помощью этой обертки можно управлять всякими баффами-дебаффами - прочее.

## Смерть

Мне немного не нравится, что часто встречаются проверки на нулевое здоровье:

```
if (GameController.Instance.playerHealthSystem.GetHealthAmount() > 0)
```

Вообще (хоть это и верно в 99% случаев) нулевое здоровье != смерть. Можно представить какие-то там абилки берсеркеров, которые еще какое-то время живут и дерутся при нулевом хп. Также, смерть может наступить и еще от некоторых специфических условий, не только от снижения хп до 0, например, смерть от тетрадки смерти. Нужно разделить эти понятия. Вопрос реализации, как и вообще всего, остается открытым. Можно хранить bool isAlive, которые обновляется при каких-то там eventах, можно что-то получше или извращеннее.

## HealthBar

Его задача одна: отображать хп. Точка.
Ему должно быть пофиг, похили ли там, задамажили ли там игрока.

Также лучше сделать единое событие changedHealth, а не следить сразу за всеми:

```
private void healthSystem_onHeal(object sender, System.EventArgs e) {
    setHealth(GameController.Instance.playerHealthSystem.GetHealthNormalized());
}

private void healthSystem_onDamage(object sender, System.EventArgs e) {
    setHealth(GameController.Instance.playerHealthSystem.GetHealthNormalized());
}
```

И тем более, он не должен никак влиять на игрока!

```
public void GetDamage(int damage)
{
    GameController.Instance.playerHealthSystem.Damage(damage);
}
```

## MovementScripts

Можно ли как-то разбить этот файл на отдельные логически связные куски? Если да, то стоит это сделать. Вроде бы вырисовываются отдельные куски **Jump** и **Dash**.

В целом про механики, на примере dash. Мне не нравится этот момент:

```
public void MovementController()
{
    float moveSpeed = 20f;
    if (!inDash) // вот этот момент
    {
        ...
    }
```

**Dash** явно диктует **MovementController** способ реализации. Что, если dash изменится? Или мы захотим его удалить? Придется править, пока не очень много. Но если будет больше механик (рассмотрим пока только передвижение), может возникать жесткий хаос. 

### Что делать?

Предоставим возможность механикам менять данные, на основе которых, уже наш контроллер будет функционировать. Но для начала нам надо добавить эти данные.

Надо заиксировать моменты, которые отличаются при использовании даша и без него.

```
if (!inDash)
{
    if (Input.GetKey(KeyCode.A) || Input.GetKey(KeyCode.LeftArrow))
    {
        GameController.Instance.playerRB.velocity = new Vector2(-moveSpeed, playerRB.velocity.y);
        animator.SetInteger("AnimState", 2);
    }
    ...
}
```

Здесь мы видим, что есть влияние на возможность управления игроком.

***Решение***: ну так выделим этот момент управляемости, например, как bool isHandled, или вообще в отдельный компонент. Даш сможет изменять этот момент, а контроллер просто подрубать или вырубать управляемость. Заметим, что влияние косвенное, через данные, а прямого нет. Это потом может пригодиться. По крайней мере, не придется на всех кнопках ставить эту проверку.

```
if (!inDash)
{
    float gravity = GameController.Instance.playerRB.gravityScale;
    GameController.Instance.playerRB.gravityScale = 0f;
    inDash = true;
    yield return new WaitForSeconds(0.15f);
    inDash = false;
    GameController.Instance.playerRB.gravityScale = gravity;
}
```

Видим, что даш влияет и на гравитацию персонажа. Ну здесь можно оставить и так, а можно сделать отдельные функции для управления gravity.

## Физические касания

Вот для таких моментов обычно предусматриваются встроенные библиотечные функции:

```
public bool IsGrounded()
{
    RaycastHit2D hit = Physics2D.BoxCast(GameController.Instance.playerBC.bounds.center, GameController.Instance.playerBC.bounds.size, 0f, Vector2.down, 1f, platformMask);
    return hit.collider != null;
}
```

Собственно, вот и она: [Rigidbody2D.IsTouchingLayers](https://docs.unity3d.com/ScriptReference/Rigidbody2D.IsTouchingLayers.html).

Вообще в документации куча всего полезного. Например, в этом же разделе про **Rigidbody2D** есть функции, которые позволяют применить силу к физическому телу. Таким образом можно попробовать сделать тот самый "толчок" от объекта, который задамажил. Правда, так как вы меняете velocity в основном, то возможны проблемы - типо объект отталкивается, игрок нажимает клавишу, просчитанная после получения силы скорость мгновенно меняется и толчок пропадает. Надо тестить.

# Что там по архитектуре (мысли и попытки исправить)

Впрочем, кажется достаточно простой и понятной идея использовать какие-то глобальные менеджеры, которые будут контролировать игру. 

Но пока это выглядит не очень. Во-первых, почему в **GameController** висят банально **ВСЕ** скрипты? Логично, чтобы в нем была ссылка только на менеджер игрока, который в свою очередь добавляет нужные скрипты для игрока. 

Во-вторых, нужно попытаться четко разграничить зоны ответственности за игровую логику. Кто отвечает за функцию спавна игрока? Кто отвечает за получение игроком урона? Кто отвечает за отображение полоски здоровья? Ну и так далее. 

В целом, если с этим разобраться, то половина работы уже будет сделана.

В данный момент (5 часов утра 04.01.2020) попробую расписать на бумаге какую-то структуру.